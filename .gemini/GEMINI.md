# GEMINI.md - 智能工作规则

版本：v1.0
作者：wwj
更新：2026-01-05

---

## 核心原则（不可违反）

| 原则 | 说明 |
|------|------|
| 质量第一 | 代码质量和系统安全不可妥协 |
| 中文交流 | 统一使用中文回复、注释和文档 |
| 完整实现 | 禁止 MVP/占位/TODO，必须完整可运行 |

---

## 质量标准

### 工程原则

- **架构设计**：SOLID、DRY、关注点分离
- **代码质量**：清晰命名、合理抽象、必要中文注释
- **测试要求**：可测试设计，单元测试覆盖

### 性能意识

- 考虑时间复杂度和空间复杂度
- 优化内存使用和 IO 操作
- 处理异常情况和边界条件

---

## 工具指南

### 工具选择优先级

| 需求 | 首选 | 降级方案 |
|------|------|---------|
| 技术文档查询 | Context7 | 内置搜索 |
| 复杂任务规划 | Sequential-Thinking | 手动分解 |
| 本地文件/命令 | 内置工具 | - |

### MCP 调用规则

**核心策略**：
- 审慎单选：每轮最多 1 个 MCP 服务
- 序贯调用：多服务需求时必须串行
- 最小范围：精确限定查询参数

**Context7 使用流程**：
1. `resolve-library-id` → 确定库标识
2. `get-library-docs` → 获取文档（tokens ≤ 5000）

**Sequential-Thinking 使用场景**：
- 复杂功能设计和规划
- 多步骤任务分解
- 架构决策分析

**错误处理**：
- 429 限流：退避 20s，降低参数范围
- 5xx/超时：单次重试，退避 2s
- 无结果：缩小范围或请求澄清

---

## 工作流程

### 任务类型适配

| 类型 | 流程调整 |
|------|---------|
| 紧急修复 | 精简流程，保留核心质量检查 |
| 新功能开发 | 完整流程，强调设计和测试 |
| 重构优化 | 重点关注架构和性能标准 |

### 关键检查点

**任务开始**：
- [ ] 根据任务特征选择适配策略
- [ ] 确认工具可用性和降级方案

**编码前**：
- [ ] 使用工具理解现有代码
- [ ] 制定实施计划和质量标准

**完成后**：
- [ ] 验证功能正确性和代码质量
- [ ] 更新相关测试和文档

---

## 行为准则

| 准则 | 说明 |
|------|------|
| 查询胜过猜测 | 不确定时先查证 |
| 复用胜过创造 | 优先使用现有代码 |
| 测试胜过跳过 | 确保代码可验证 |
| 诚实胜过假装 | 不懂就说不懂 |

---

## 工具调用简报格式

每次 MCP 调用后，在回复末尾附加：

```
【MCP 调用简报】
- 服务：<服务名>
- 触发：<具体原因>
- 参数：<关键参数摘要>
- 结果：<命中数/主要来源>
- 状态：<成功|重试|降级>
```

---

## 前端修改安全约束

修改 Vue/React 文件时，必须遵守以下规则，防止破坏已有功能。

### 绝对禁止修改

| 类型 | 说明 | 示例 |
|------|------|------|
| 数据绑定 | v-model / v-bind 的字段名 | `v-model="form.username"` |
| Props | props 定义和传递的属性名 | `:user-id="userId"` |
| 事件 | emit 事件名和 @ 绑定 | `@click="handleSubmit"` |
| 响应式变量 | ref / reactive 变量名 | `const loading = ref(false)` |
| API 调用 | 接口路径、参数、响应处理 | `api.getUser(id)` |
| 类型定义 | TypeScript interface/type | `interface User { ... }` |
| 函数名 | 已有的方法和函数名 | `function handleSubmit()` |

### 允许修改

| 类型 | 说明 | 示例 |
|------|------|------|
| 布局结构 | div / el-row / el-col 层级 | 减少嵌套层级 |
| 布局组件 | Element Plus 布局相关属性 | `span` / `gutter` / `justify` |
| CSS 样式 | style 中的样式代码 | `padding` / `margin` / `flex` |
| 样式类名 | 纯样式用途的 class | `class="container"` |
| 包裹元素 | 不影响逻辑的外层容器 | 添加/移除布局用的 div |

### 修改前检查

修改任何前端文件前，先识别：
1. 哪些是**数据绑定**（v-model、:prop）→ 不动
2. 哪些是**事件处理**（@click、@change）→ 不动
3. 哪些是**布局结构**（div、el-row）→ 可优化

---

## 布局一致性规则

创建或修改前端页面时，必须确保与项目中其他页面保持视觉和结构一致。

### 三大原则

| 原则 | 说明 |
|------|------|
| **先查后写** | 创建新页面前，先读取 2-3 个现有页面，提取布局模式 |
| **变量优先** | 间距/尺寸必须使用 CSS 变量或设计 Token，禁止硬编码 |
| **结构一致** | 同类型页面使用相同的 DOM 结构 |

### 间距系统约束

所有间距值必须是 **4px 的倍数**：

| 允许 | 禁止 |
|------|------|
| 4, 8, 12, 16, 20, 24, 32, 40, 48 | 5, 7, 13, 17, 23, 25, 30 |

推荐使用变量而非硬编码：
- ✅ `padding: var(--page-padding)`
- ✅ `gap: var(--spacing-md)`
- ❌ `padding: 23px`
- ❌ `margin-top: 17px`

### 页面结构规范

标准页面应遵循统一结构：

```
┌─────────────────────────────────────┐
│ 页面标题区（固定高度）               │
│ [图标] 标题 | 描述        [操作按钮] │
├─────────────────────────────────────┤
│ 内容区（统一 padding）               │
│                                     │
└─────────────────────────────────────┘
```

### 新建页面检查清单

创建新页面前必须执行：

- [ ] 读取了 2-3 个现有页面的布局结构
- [ ] 页面标题区的 padding-top 与其他页面一致
- [ ] 内容区的 padding 使用了变量或与其他页面相同
- [ ] 不存在硬编码的非 4 倍数间距值
- [ ] CSS 类名与现有命名风格一致

### 禁止行为

- ❌ 每个页面单独定义不同的 padding
- ❌ 使用硬编码的非 4 倍数间距
- ❌ 新页面与现有页面结构差异过大
- ❌ 不查看现有页面就创建新页面

---

## 覆盖层组件规范

系统中所有覆盖层（蒙版、遮罩、状态提示）必须统一管理，禁止各页面单独实现。

### 核心原则

| 原则 | 说明 |
|------|------|
| **容器统一** | 所有页面内容区容器结构一致（前提条件） |
| **单一来源** | 同类覆盖层只有一份组件实现 |
| **统一定位** | 所有覆盖层使用相同的定位策略 |
| **统一层级** | z-index 按类型分配，避免冲突 |
| **统一居中** | 内容居中方式一致，禁止硬编码偏移 |

### 页面容器规范（前提条件）

覆盖层位置一致的前提是**页面容器结构一致**。

**所有页面的内容区容器必须**：
- 设置统一的最小高度（撑满可视区域）
- 设置 `position: relative`（作为覆盖层定位基准）
- 使用一致的 DOM 结构层级

**容器结构示意**：

```
┌─────────────────────────────────────────┐
│ App                                     │
│ ┌─────────┬───────────────────────────┐ │
│ │         │ PageContent               │ │
│ │ Sidebar │ - position: relative      │ │
│ │         │ - min-height: 统一值       │ │
│ │         │ ┌───────────────────────┐ │ │
│ │         │ │ 页面具体内容           │ │ │
│ │         │ └───────────────────────┘ │ │
│ │         │ ┌───────────────────────┐ │ │
│ │         │ │ 覆盖层（absolute）     │ │ │
│ │         │ └───────────────────────┘ │ │
│ └─────────┴───────────────────────────┘ │
└─────────────────────────────────────────┘
```

**禁止行为**：
- ❌ 不同页面内容区容器高度不一致
- ❌ 容器未设置 position: relative
- ❌ 覆盖层定位基准不明确

### 覆盖层类型

系统中常见的覆盖层类型：

| 类型 | 场景 |
|------|------|
| 权限蒙版 | 会员专属、功能受限、未登录 |
| 加载状态 | 数据加载中、提交中 |
| 空状态 | 无数据、无结果 |
| 错误状态 | 加载失败、网络异常 |
| 确认蒙版 | 危险操作确认 |

### 一致性要求

**定位方式**：
- 所有覆盖层应使用相同的定位策略
- 建议相对于内容区定位，避免遮挡导航/侧边栏
- 禁止使用 `margin-top` 等硬编码偏移值

**居中方式**：
- 所有覆盖层内容居中方式应一致
- 禁止不同页面使用不同的居中实现

**层级管理**：
- 项目应定义统一的 z-index 规范
- 不同类型覆盖层应有明确的层级顺序
- 禁止随意使用 `z-index: 999` 等魔法数字

### 蒙版定位规则（解决位置跳动）

**问题**：蒙版在不同页面切换时位置上下跳动，原因是相对于「内容高度」居中而非「固定高度基准」居中。

**核心原则**：

```
❌ 错误：蒙版相对于「内容高度」居中
   → 内容多则蒙版偏下，内容少则蒙版偏上

✅ 正确：蒙版相对于「固定高度基准」居中
   → 无论内容多少，位置始终一致
```

**两种正确方案**：

| 方案 | 定位方式 | 适用场景 |
|------|---------|---------|
| 视口居中 | `position: fixed` + `inset: 0` | 全屏蒙版、模态框 |
| 容器居中 | 容器 `min-height` + 蒙版 `absolute` | 页面级蒙版（不遮挡导航） |

**方案一：视口居中**

```css
.overlay {
  position: fixed;
  inset: 0;
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 100;
}
```

**方案二：容器居中（推荐）**

```css
/* 容器必须有固定的最小高度 */
.page-content {
  position: relative;
  min-height: calc(100vh - var(--header-height, 0px));
}

/* 蒙版相对于容器居中 */
.overlay {
  position: absolute;
  inset: 0;
  display: flex;
  align-items: center;
  justify-content: center;
}
```

**禁止做法**：
- ❌ 蒙版相对于内容高度居中（高度由内容撑开）
- ❌ 使用 `margin-top` 等硬编码偏移调整位置
- ❌ 不同页面使用不同的居中实现

**验证方法**：
- 切换不同页面，蒙版位置是否一致？
- 页面内容增减时，蒙版位置是否变化？
- 不同屏幕高度下，蒙版是否始终可见？

### 检查清单

创建或修改页面时：

**容器检查**：
- [ ] 页面内容区容器是否设置了 position: relative
- [ ] 页面内容区容器是否设置了统一的 min-height
- [ ] 容器结构是否与其他页面一致

**覆盖层检查**：
- [ ] 是否复用了项目中已有的覆盖层组件
- [ ] 是否存在重复实现的蒙版代码
- [ ] 覆盖层定位方式是否与其他页面一致
- [ ] 覆盖层居中位置是否与其他页面一致
- [ ] z-index 是否符合项目规范

### 禁止行为

- ❌ 不同页面内容区容器结构不一致
- ❌ 各页面单独实现相同功能的覆盖层
- ❌ 不同页面的覆盖层位置不一致（上蹿下跳）
- ❌ 使用硬编码偏移值定位覆盖层内容
- ❌ 随意使用 z-index 魔法数字

---

## 大文件处理策略

处理超过 500 行的文件时，必须遵循以下规则，防止 API 超时或响应截断。

### 阈值定义

| 文件大小 | 处理方式 |
|---------|---------|
| < 500 行 | 正常处理 |
| 500-1000 行 | 分 2 次处理 |
| 1000-2000 行 | 分 3-4 次处理 |
| > 2000 行 | 建议先手动拆分，或分 5+ 次处理 |

### 禁止行为

- ❌ 一次性读取 >500 行的文件全部内容
- ❌ 一次性生成 >300 行的代码文件
- ❌ 在单次响应中输出大量代码

### 必须分步执行

**读取大文件**：
```
步骤 1：读取 1-500 行，分析结构
步骤 2：读取 501-1000 行，继续分析
步骤 3：汇总分析结果
```

**生成大文件**：
```
步骤 1：生成 import 和类型定义（<100 行）
步骤 2：生成核心逻辑部分 1（<200 行）
步骤 3：生成核心逻辑部分 2（<200 行）
步骤 4：生成剩余部分
```

### 每步必须暂停

每完成一个步骤后：
1. 输出当前进度（如：已完成 2/5 步）
2. 等待用户确认"继续"
3. 再执行下一步

### 遇到 API 错误时

如果出现 `Premature close` 或超时错误：
1. 不要重试相同的大操作
2. 将操作拆分成更小的步骤
3. 告知用户需要分步执行

---

## 代码风格

### 注释规范

- ❌ **禁止行尾注释**（如 `int x = 1; // 这是注释`）
- ✅ 注释应独占一行，放在代码上方

**此规则适用于所有场景，包括**：
- 源代码文件（.js/.ts/.go/.java 等）
- Markdown 文档中的代码块
- 配置文件中的示例代码

```javascript
// ❌ 错误
const maxRetry = 3; // 最大重试次数

// ✅ 正确
// 最大重试次数
const maxRetry = 3;
```

**Bash 代码块特别强调**：

```bash
# ❌ 错误：行尾注释
curl -X POST https://api.example.com/data # 发送请求
docker run -d nginx # 启动容器

# ✅ 正确：注释独占一行
# 发送请求
curl -X POST https://api.example.com/data

# 启动容器
docker run -d nginx
```

### 语言要求

- 所有回答使用简体中文
- 代码注释使用简体中文
- 变量名、函数名保持英文

---

## 禁止行为

- ❌ 修改测试来适配错误代码
- ❌ 删除或注释掉失败的测试
- ❌ 提交调试残留（print/console.log/debugger）
- ❌ 用"注释掉旧实现"代替删除
- ❌ 主动创建文档文件（除非明确要求）
- ❌ 添加 AI 生成声明或元数据
- ❌ 使用行尾注释

---

## 技术栈偏好

| 场景 | 首选 | 备选 |
|------|------|------|
| Go 后端 | Gin + GORM | Echo, Fiber |
| Java 后端 | Spring Boot | - |
| 前端 | Vue 3 + TS + Vite + Element Plus | React + Ant Design |
| 数据库 | SQLite (轻量) / MySQL (生产) | PostgreSQL |
